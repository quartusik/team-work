library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Time_Generator is
    port (
        clk       : in std_logic; -- Zegar systemowy 50 MHz
        reset     : in std_logic; -- Reset asynchroniczny
        pulse_sec : out std_logic; -- Wyjście impulsu 1 sekundy
        pulse_min : out std_logic  -- Wyjście impulsu 1 minuty
    );
end Time_Generator;

architecture Behavioral of Time_Generator is

    -- Stała dla 1 sekundy przy zegarze 50 MHz (50,000,000 cykli)
    constant CLK_FREQ : integer := 50000000;

    -- Licznik dla sekund (zakres wystarczający dla 50mln)
    signal cnt_sec : integer range 0 to CLK_FREQ := 0;
    
    -- Licznik dla minut (0 do 60)
    signal cnt_min : integer range 0 to 60 := 0;

    -- Sygnał wewnętrzny (flaga) informujący o upływie sekundy
    signal sec_tick : std_logic := '0';

begin

    -- PROCES 1: Generowanie impulsu co 1 sekundę
    -- Działa bezpośrednio na szybkim zegarze 50 MHz
    process(clk, reset)
    begin
        if reset = '1' then
            cnt_sec <= 0;
            sec_tick <= '0';
        elsif rising_edge(clk) then
            if cnt_sec = CLK_FREQ - 1 then -- Liczymy od 0 do 49,999,999
                cnt_sec <= 0;
                sec_tick <= '1'; -- Generujemy impuls (1 cykl zegara)
            else
                cnt_sec <= cnt_sec + 1;
                sec_tick <= '0';
            end if;
        end if;
    end process;

    -- PROCES 2: Generowanie impulsu co 1 minutę
    -- Reaguje na flagę 'sec_tick' z pierwszego procesu
    process(clk, reset)
    begin
        if reset = '1' then
            cnt_min <= 0;
            pulse_min <= '0';
        elsif rising_edge(clk) then
            if sec_tick = '1' then -- Sprawdzamy, czy minęła sekunda (Enable)
                if cnt_min = 59 then -- Jeśli to była 60-ta sekunda (0-59)
                    cnt_min <= 0;
                    pulse_min <= '1'; -- Generujemy impuls minuty
                else
                    cnt_min <= cnt_min + 1;
                    pulse_min <= '0';
                end if;
            else
                pulse_min <= '0'; -- W pozostałych cyklach wyjście jest 0
            end if;
        end if;
    end process;

    -- Przypisanie sygnału wewnętrznego do wyjścia
    pulse_sec <= sec_tick;

end Behavioral;





5

full_adder.vhd
library ieee;
use ieee.std_logic_1164.all;

entity full_adder is
    port (
        a  : in std_logic;
        b  : in std_logic;
        ci : in std_logic; -- Carry In (przeniesienie wejściowe)
        s  : out std_logic; -- Suma
        co : out std_logic  -- Carry Out (przeniesienie wyjściowe)
    );
end full_adder;

architecture dataflow of full_adder is
begin
    s  <= a xor b xor ci;
    co <= (a and b) or (ci and (a xor b));
end dataflow;

adder_3bit.vhd
library ieee;
use ieee.std_logic_1164.all;

entity adder_3bit is
    port (
        input_A : in std_logic_vector(2 downto 0); -- Wejście A (3 bity)
        input_B : in std_logic_vector(2 downto 0); -- Wejście B (3 bity)
        cin     : in std_logic;                    -- Przeniesienie początkowe (zazwyczaj 0)
        sum     : out std_logic_vector(2 downto 0); -- Wynik
        cout    : out std_logic                     -- Ostatnie przeniesienie
    );
end adder_3bit;

architecture Structural of adder_3bit is
    -- 1. Deklarujemy komponent (nasz symbol z Kroku 1)
    component full_adder is
        port (
            a, b, ci : in std_logic;
            s, co    : out std_logic
        );
    end component;

    -- 2. Deklarujemy wewnętrzne przewody na przeniesienia (c1, c2)
    signal c1, c2 : std_logic;

begin
    -- 3. Łączymy klocki (Instancjonowanie)
    
    -- Bit 0 (Najmłodszy)
    FA0: full_adder port map (
        a  => input_A(0),
        b  => input_B(0),
        ci => cin,        -- Tu wchodzi główne wejście cin
        s  => sum(0),
        co => c1          -- Wyjście idzie do kabla c1
    );

    -- Bit 1 (Środkowy)
    FA1: full_adder port map (
        a  => input_A(1),
        b  => input_B(1),
        ci => c1,         -- Bierze przeniesienie z FA0
        s  => sum(1),
        co => c2          -- Wyjście idzie do kabla c2
    );

    -- Bit 2 (Najstarszy)
    FA2: full_adder port map (
        a  => input_A(2),
        b  => input_B(2),
        ci => c2,         -- Bierze przeniesienie z FA1
        s  => sum(2),
        co => cout        -- To jest ostateczne przeniesienie
    );

end Structural;


