library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Time_Generator is
    port (
        clk       : in std_logic; -- Zegar systemowy 50 MHz
        reset     : in std_logic; -- Reset asynchroniczny
        pulse_sec : out std_logic; -- Wyjście impulsu 1 sekundy
        pulse_min : out std_logic  -- Wyjście impulsu 1 minuty
    );
end Time_Generator;

architecture Behavioral of Time_Generator is

    -- Stała dla 1 sekundy przy zegarze 50 MHz (50,000,000 cykli)
    constant CLK_FREQ : integer := 50000000;

    -- Licznik dla sekund (zakres wystarczający dla 50mln)
    signal cnt_sec : integer range 0 to CLK_FREQ := 0;
    
    -- Licznik dla minut (0 do 60)
    signal cnt_min : integer range 0 to 60 := 0;

    -- Sygnał wewnętrzny (flaga) informujący o upływie sekundy
    signal sec_tick : std_logic := '0';

begin

    -- PROCES 1: Generowanie impulsu co 1 sekundę
    -- Działa bezpośrednio na szybkim zegarze 50 MHz
    process(clk, reset)
    begin
        if reset = '1' then
            cnt_sec <= 0;
            sec_tick <= '0';
        elsif rising_edge(clk) then
            if cnt_sec = CLK_FREQ - 1 then -- Liczymy od 0 do 49,999,999
                cnt_sec <= 0;
                sec_tick <= '1'; -- Generujemy impuls (1 cykl zegara)
            else
                cnt_sec <= cnt_sec + 1;
                sec_tick <= '0';
            end if;
        end if;
    end process;

    -- PROCES 2: Generowanie impulsu co 1 minutę
    -- Reaguje na flagę 'sec_tick' z pierwszego procesu
    process(clk, reset)
    begin
        if reset = '1' then
            cnt_min <= 0;
            pulse_min <= '0';
        elsif rising_edge(clk) then
            if sec_tick = '1' then -- Sprawdzamy, czy minęła sekunda (Enable)
                if cnt_min = 59 then -- Jeśli to była 60-ta sekunda (0-59)
                    cnt_min <= 0;
                    pulse_min <= '1'; -- Generujemy impuls minuty
                else
                    cnt_min <= cnt_min + 1;
                    pulse_min <= '0';
                end if;
            else
                pulse_min <= '0'; -- W pozostałych cyklach wyjście jest 0
            end if;
        end if;
    end process;

    -- Przypisanie sygnału wewnętrznego do wyjścia
    pulse_sec <= sec_tick;

end Behavioral;





5

full_adder.vhd
library ieee;
use ieee.std_logic_1164.all;

entity full_adder is
    port (
        a  : in std_logic;
        b  : in std_logic;
        ci : in std_logic; -- Carry In (przeniesienie wejściowe)
        s  : out std_logic; -- Suma
        co : out std_logic  -- Carry Out (przeniesienie wyjściowe)
    );
end full_adder;

architecture dataflow of full_adder is
begin
    s  <= a xor b xor ci;
    co <= (a and b) or (ci and (a xor b));
end dataflow;

adder_3bit.vhd
library ieee;
use ieee.std_logic_1164.all;

entity adder_3bit is
    port (
        input_A : in std_logic_vector(2 downto 0); -- Wejście A (3 bity)
        input_B : in std_logic_vector(2 downto 0); -- Wejście B (3 bity)
        cin     : in std_logic;                    -- Przeniesienie początkowe (zazwyczaj 0)
        sum     : out std_logic_vector(2 downto 0); -- Wynik
        cout    : out std_logic                     -- Ostatnie przeniesienie
    );
end adder_3bit;

architecture Structural of adder_3bit is
    -- 1. Deklarujemy komponent (nasz symbol z Kroku 1)
    component full_adder is
        port (
            a, b, ci : in std_logic;
            s, co    : out std_logic
        );
    end component;

    -- 2. Deklarujemy wewnętrzne przewody na przeniesienia (c1, c2)
    signal c1, c2 : std_logic;

begin
    -- 3. Łączymy klocki (Instancjonowanie)
    
    -- Bit 0 (Najmłodszy)
    FA0: full_adder port map (
        a  => input_A(0),
        b  => input_B(0),
        ci => cin,        -- Tu wchodzi główne wejście cin
        s  => sum(0),
        co => c1          -- Wyjście idzie do kabla c1
    );

    -- Bit 1 (Środkowy)
    FA1: full_adder port map (
        a  => input_A(1),
        b  => input_B(1),
        ci => c1,         -- Bierze przeniesienie z FA0
        s  => sum(1),
        co => c2          -- Wyjście idzie do kabla c2
    );

    -- Bit 2 (Najstarszy)
    FA2: full_adder port map (
        a  => input_A(2),
        b  => input_B(2),
        ci => c2,         -- Bierze przeniesienie z FA1
        s  => sum(2),
        co => cout        -- To jest ostateczne przeniesienie
    );

end Structural;




5 AI
To zadanie polega na stworzeniu struktury hierarchicznej: najpierw tworzysz mały klocek (Sumator 1-bitowy), robisz z niego symbol, a potem używasz go 3 razy, żeby zbudować Sumator 3-bitowy.

Ponieważ jestem AI tekstowym, nie mogę fizycznie "wgrać" plików `.bdf` (schematów graficznych) na Twój komputer. Mogę jednak podać Ci **dokładny kod VHDL (Styl Strukturalny)**, który jest tekstowym odpowiednikiem tego schematu, oraz instrukcję, jak to wyklikać w edytorze graficznym Quartusa, jeśli wolisz rysować.

Oto kompletne rozwiązanie.

### KROK 1: Element Podstawowy (Full Adder 1-bitowy)

Najpierw musisz stworzyć pojedynczy sumator.

**Opcja A: Kod VHDL (zapisz jako `full_adder.vhd`)**

```vhdl
library ieee;
use ieee.std_logic_1164.all;

entity full_adder is
    port (
        a  : in std_logic;
        b  : in std_logic;
        ci : in std_logic; -- Carry In (przeniesienie wejściowe)
        s  : out std_logic; -- Suma
        co : out std_logic  -- Carry Out (przeniesienie wyjściowe)
    );
end full_adder;

architecture dataflow of full_adder is
begin
    s  <= a xor b xor ci;
    co <= (a and b) or (ci and (a xor b));
end dataflow;

```

**Jak zrobić z tego symbol w Quartusie?**

1. Skompiluj ten plik.
2. Kliknij prawym na plik w drzewku projektu -> **Create Symbol Files for Current File**.
3. Teraz masz gotowy "klocek" `full_adder`.

---

### KROK 2: Schemat Zastępczy 3-bitowy (Top Level)

Teraz łączymy trzy sumatory 1-bitowe w łańcuch (Ripple Carry Adder).

**Opcja A: Kod VHDL (Styl Strukturalny - odpowiednik rysowania schematu)**
Zapisz to jako `adder_3bit.vhd`.

```vhdl
library ieee;
use ieee.std_logic_1164.all;

entity adder_3bit is
    port (
        input_A : in std_logic_vector(2 downto 0); -- Wejście A (3 bity)
        input_B : in std_logic_vector(2 downto 0); -- Wejście B (3 bity)
        cin     : in std_logic;                    -- Przeniesienie początkowe (zazwyczaj 0)
        sum     : out std_logic_vector(2 downto 0); -- Wynik
        cout    : out std_logic                     -- Ostatnie przeniesienie
    );
end adder_3bit;

architecture Structural of adder_3bit is
    -- 1. Deklarujemy komponent (nasz symbol z Kroku 1)
    component full_adder is
        port (
            a, b, ci : in std_logic;
            s, co    : out std_logic
        );
    end component;

    -- 2. Deklarujemy wewnętrzne przewody na przeniesienia (c1, c2)
    signal c1, c2 : std_logic;

begin
    -- 3. Łączymy klocki (Instancjonowanie)
    
    -- Bit 0 (Najmłodszy)
    FA0: full_adder port map (
        a  => input_A(0),
        b  => input_B(0),
        ci => cin,        -- Tu wchodzi główne wejście cin
        s  => sum(0),
        co => c1          -- Wyjście idzie do kabla c1
    );

    -- Bit 1 (Środkowy)
    FA1: full_adder port map (
        a  => input_A(1),
        b  => input_B(1),
        ci => c1,         -- Bierze przeniesienie z FA0
        s  => sum(1),
        co => c2          -- Wyjście idzie do kabla c2
    );

    -- Bit 2 (Najstarszy)
    FA2: full_adder port map (
        a  => input_A(2),
        b  => input_B(2),
        ci => c2,         -- Bierze przeniesienie z FA1
        s  => sum(2),
        co => cout        -- To jest ostateczne przeniesienie
    );

end Structural;

```

**Opcja B: Rysowanie w Edytorze Graficznym (Block Diagram/Schematic File .bdf)**
Jeśli zadanie wymaga pliku `.bdf`:

1. Otwórz **File -> New -> Block Diagram/Schematic File**.
2. Kliknij dwukrotnie na tło, wpisz `full_adder` (symbol stworzony w Kroku 1) i wstaw go **3 razy**.
3. Dodaj wejścia (`input pin`) i wyjścia (`output pin`).
4. Połącz je drutami (narzędzie **Orthogonal Node Tool**) dokładnie tak, jak w kodzie powyżej:
* Wyjście `co` pierwszego sumatora do wejścia `ci` drugiego.
* Wyjście `co` drugiego sumatora do wejścia `ci` trzeciego.



---

### KROK 3: Testowanie (Symulacja)

Aby przetestować ten układ ("przetestuj schemat"), musisz stworzyć plik **Vector Waveform File (.vwf)**.

1. **File -> New -> University Program VWF**.
2. **Edit -> Insert -> Insert Node or Bus**.
3. Dodaj `input_A`, `input_B`, `cin` oraz wyjścia `sum`, `cout`.
4. Ustaw wartości testowe:
* `input_A`: Ustaw jako licznik (Count Value) lub wpisz np. `001` (1).
* `input_B`: Wpisz np. `010` (2).
* `cin`: Ustaw na `0`.


5. Uruchom symulację (**Run Functional Simulation**).

**Oczekiwany wynik:**

* Jeśli `A = 1 (001)` i `B = 2 (010)`, to wynik `sum` powinien być `3 (011)`, a `cout` powinien być `0`.
* Jeśli `A = 7 (111)` i `B = 1 (001)`, to wynik `sum` powinien być `0 (000)`, a `cout` powinien być `1` (Przepełnienie).



