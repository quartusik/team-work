Kod HDL (Verilog / VHDL / SystemVerilog) – Najważniejsza i najczęściej używana metoda. Piszesz kod opisujący stany i przejścia (zazwyczaj używając instrukcji case). Daje pełną kontrolę i jest standardem w pracy inżynierskiej.

Edytor Graficzny (.smf – State Machine File) – Rysujesz wizualny diagram stanów (kółka i strzałki), a Quartus automatycznie generuje z niego kod HDL. Dobre do nauki i dokumentacji.



Schemat (.bdf – Block Diagram File) – Ręczne układanie bramek logicznych i przerzutników na schemacie. Metoda przestarzała (legacy) i obecnie niezalecana.




2.

Inferencja HDL – Najprostsza metoda. Definiujesz tablicę w kodzie Verilog/VHDL (np. reg [7:0] mem [0:255]), a syntezer automatycznie rozpoznaje ją i zamienia na blokową pamięć RAM FPGA.

IP Catalog (dawniej MegaWizard) – Użycie graficznego kreatora. Pozwala precyzyjnie skonfigurować parametry (np. ROM, Dual-Port RAM) i łatwo podpiąć plik inicjalizacyjny (.mif lub .hex).

Platform Designer (Qsys) – Stosowane przy budowie systemów SoC (np. z procesorem Nios II). Pozwala łatwo dodać pamięć on-chip lub kontrolery pamięci zewnętrznej (SDRAM/DDR) do magistrali systemowej.


3.
Syntezowalne: Zamieniają się na fizyczny sprzęt (bramki logiczne). Kompilator musi znać dokładną liczbę powtórzeń przed uruchomieniem (pętla jest "rozwijana" na równoległe bloki).

Przykład: for (i=0; i<8; i=i+1) (np. do operacji na bitach).

Niesyntezowalne: Działają tylko w symulacji. Służą do generowania sygnałów testowych, mogą trwać w nieskończoność lub zawierać opóźnienia czasowe.

Przykład: forever #5 clk = ~clk; (generator zegara).

Oto bardzo krótkie przykłady w VHDL:

1. Pętla Syntezowalna (Tworzy logikę sprzętową) Musi mieć z góry określony zakres (np. 0 to 7).

VHDL

-- Tworzy 8 równoległych bramek AND
for i in 0 to 7 loop
    y(i) <= a(i) and b(i);
end loop;
2. Pętla Niesyntezowalna (Tylko symulacja) Używa czasu (wait for) lub nie kończy się.

VHDL

-- Generator zegara (nieskończona pętla z czasem)
loop
    clk <= not clk;
    wait for 10 ns; 
end loop;



4. 
library ieee;
use ieee.std_logic_1164.all;

entity andor is
    port (
        i1, i2, i3 : in std_logic; -- lub 'bit' zależnie od polecenia
        output     : out std_logic
    );
end andor;

architecture Structural of andor is
    -- Deklaracja komponentów
    component AND2 is
        port (A, B : in std_logic; F1 : out std_logic);
    end component;

    component OR2 is
        port (X, Y : in std_logic; F2 : out std_logic);
    end component;

    -- Sygnał wewnętrzny (drut łączący bramki)
    signal wire : std_logic; 

begin
    -- Mapowanie portów
    Gate1: AND2 port map (A => i1, B => i2, F1 => wire);
    Gate2: OR2  port map (X => wire, Y => i3, F2 => output);
    
end Structural;


5.
Ten kod odpowiada za realizację funkcji logicznej (kombinacyjnej) w formie przypisania współbieżnego.Fizycznie opisuje on strukturę bramek logicznych (Suma Iloczynów):Bramki AND obliczającej $A \cdot B \cdot C$.Bramki AND obliczającej $C \cdot D$.Bramki OR, która sumuje wyniki tych dwóch operacji.Ponieważ jest to przypisanie poza procesem (w ciele architektury), działa ono równolegle (współbieżnie) – każda zmiana sygnałów A, B, C lub D natychmiast aktualizuje wyjście X.


6.

ram_32x8.vhd

VHDL

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity ram_32x8 is
    port (
        clk  : in    std_logic;
        addr : in    std_logic_vector(4 downto 0);
        we   : in    std_logic;
        data : inout std_logic_vector(7 downto 0)
    );
end entity;

architecture rtl of ram_32x8 is
    type mem_t is array(0 to 31) of std_logic_vector(7 downto 0);
    signal ram : mem_t;
    
    attribute ram_init_file : string;
    attribute ram_init_file of ram : signal is "init.mif";

begin
    process(clk)
    begin
        if rising_edge(clk) then
            if we = '1' then
                ram(to_integer(unsigned(addr))) <= data;
            end if;
        end if;
    end process;

    data <= ram(to_integer(unsigned(addr))) when we = '0' else (others => 'Z');

end architecture;


init.mif

Plaintext

DEPTH = 32;
WIDTH = 8;
ADDRESS_RADIX = DEC;
DATA_RADIX = HEX;

CONTENT
BEGIN
    0 : FF;
    1 : AA;
    [2..31] : 00;
END;
